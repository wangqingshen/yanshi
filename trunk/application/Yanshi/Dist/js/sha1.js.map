{"version":3,"sources":["sha1.js"],"names":["hex_sha1","s","binb2hex","core_sha1","str2binb","length","chrsz","b64_sha1","binb2b64","str_sha1","binb2str","hex_hmac_sha1","key","data","core_hmac_sha1","b64_hmac_sha1","str_hmac_sha1","sha1_vm_test","x","len","w","Array","a","b","c","d","e","i","olda","oldb","oldc","oldd","olde","j","rol","t","safe_add","sha1_ft","sha1_kt","bkey","ipad","opad","hash","concat","y","lsw","msw","num","cnt","str","bin","mask","charCodeAt","String","fromCharCode","binarray","hex_tab","hexcase","charAt","tab","triplet","b64pad"],"mappings":"AAoBA,QAASA,UAASC,GACd,MAAOC,UAASC,UAAUC,SAASH,GAAIA,EAAEI,OAASC,QAGtD,QAASC,UAASN,GACd,MAAOO,UAASL,UAAUC,SAASH,GAAIA,EAAEI,OAASC,QAGtD,QAASG,UAASR,GACd,MAAOS,UAASP,UAAUC,SAASH,GAAIA,EAAEI,OAASC,QAGtD,QAASK,eAAcC,EAAKC,GACxB,MAAOX,UAASY,eAAeF,EAAKC,IAGxC,QAASE,eAAcH,EAAKC,GACxB,MAAOL,UAASM,eAAeF,EAAKC,IAGxC,QAASG,eAAcJ,EAAKC,GACxB,MAAOH,UAASI,eAAeF,EAAKC,IAMxC,QAASI,gBACL,MAA0B,4CAAnBjB,SAAS,OAMpB,QAASG,WAAUe,EAAGC,GAElBD,EAAEC,GAAO,IAAM,KAAS,GAAKA,EAAM,GACnCD,GAAIC,EAAM,IAAM,GAAM,GAAK,IAAMA,CASjC,KAAK,GAPDC,GAAIC,MAAM,IACVC,EAAI,WACJC,aACAC,cACAC,EAAI,UACJC,cAEKC,EAAI,EAAGA,EAAIT,EAAEb,OAAQsB,GAAK,GAAI,CAOnC,IAAK,GANDC,GAAON,EACPO,EAAON,EACPO,EAAON,EACPO,EAAON,EACPO,EAAON,EAEFO,EAAI,EAAGA,EAAI,GAAIA,IAAK,CACrBA,EAAI,GAAIb,EAAEa,GAAKf,EAAES,EAAIM,GACpBb,EAAEa,GAAKC,IAAId,EAAEa,EAAI,GAAKb,EAAEa,EAAI,GAAKb,EAAEa,EAAI,IAAMb,EAAEa,EAAI,IAAK,EAC7D,IAAIE,GAAIC,SAASA,SAASF,IAAIZ,EAAG,GAAIe,QAAQJ,EAAGV,EAAGC,EAAGC,IAAKW,SAASA,SAASV,EAAGN,EAAEa,IAAKK,QAAQL,IAC/FP,GAAID,EACJA,EAAID,EACJA,EAAIU,IAAIX,EAAG,IACXA,EAAID,EACJA,EAAIa,EAGRb,EAAIc,SAASd,EAAGM,GAChBL,EAAIa,SAASb,EAAGM,GAChBL,EAAIY,SAASZ,EAAGM,GAChBL,EAAIW,SAASX,EAAGM,GAChBL,EAAIU,SAASV,EAAGM,GAEpB,MAAOX,OAAMC,EAAGC,EAAGC,EAAGC,EAAGC,GAQ7B,QAASW,SAAQF,EAAGZ,EAAGC,EAAGC,GACtB,MAAIU,GAAI,GAAYZ,EAAIC,GAAQD,EAAKE,EACjCU,EAAI,GAAWZ,EAAIC,EAAIC,EACvBU,EAAI,GAAYZ,EAAIC,EAAMD,EAAIE,EAAMD,EAAIC,EACrCF,EAAIC,EAAIC,EAMnB,QAASa,SAAQH,GACb,MAAQA,GAAI,GAAM,WAAcA,EAAI,GAAM,WAAcA,EAAI,0BAMhE,QAASrB,gBAAeF,EAAKC,GACzB,GAAI0B,GAAOnC,SAASQ,EAChB2B,GAAKlC,OAAS,KAAIkC,EAAOpC,UAAUoC,EAAM3B,EAAIP,OAASC,OAI1D,KAAK,GAFDkC,GAAOnB,MAAM,IACboB,EAAOpB,MAAM,IACRM,EAAI,EAAGA,EAAI,GAAIA,IACpBa,EAAKb,GAAe,UAAVY,EAAKZ,GACfc,EAAKd,GAAe,WAAVY,EAAKZ,EAGnB,IAAIe,GAAOvC,UAAUqC,EAAKG,OAAOvC,SAASS,IAAQ,IAAMA,EAAKR,OAASC,MACtE,OAAOH,WAAUsC,EAAKE,OAAOD,GAAO,KAOxC,QAASN,UAASlB,EAAG0B,GACjB,GAAIC,IAAW,MAAJ3B,IAAmB,MAAJ0B,GACtBE,GAAO5B,GAAK,KAAO0B,GAAK,KAAOC,GAAO,GAC1C,OAAQC,IAAO,GAAa,MAAND,EAM1B,QAASX,KAAIa,EAAKC,GACd,MAAQD,IAAOC,EAAQD,IAAS,GAAKC,EAOzC,QAAS5C,UAAS6C,GAGd,IAAK,GAFDC,GAAM7B,QACN8B,GAAQ,GAAK7C,OAAS,EACjBqB,EAAI,EAAGA,EAAIsB,EAAI5C,OAASC,MAAOqB,GAAKrB,MAC7C4C,EAAIvB,GAAK,KAAOsB,EAAIG,WAAWzB,EAAIrB,OAAS6C,IAAU,GAAKxB,EAAI,EAC/D,OAAOuB,GAMX,QAASxC,UAASwC,GAGd,IAAK,GAFDD,GAAM,GACNE,GAAQ,GAAK7C,OAAS,EACjBqB,EAAI,EAAGA,EAAiB,GAAbuB,EAAI7C,OAAasB,GAAKrB,MAC1C2C,GAAOI,OAAOC,aAAcJ,EAAIvB,GAAK,KAAQ,GAAKA,EAAI,GAAOwB,EAC7D,OAAOF,GAMX,QAAS/C,UAASqD,GAGd,IAAK,GAFDC,GAAUC,QAAU,mBAAqB,mBACzCR,EAAM,GACDtB,EAAI,EAAGA,EAAsB,EAAlB4B,EAASlD,OAAYsB,IACrCsB,GAAOO,EAAQE,OAAQH,EAAS5B,GAAK,IAAqB,GAAb,EAAIA,EAAI,GAAS,EAAM,IAAO6B,EAAQE,OAAQH,EAAS5B,GAAK,IAAqB,GAAb,EAAIA,EAAI,GAAW,GAExI,OAAOsB,GAMX,QAASzC,UAAS+C,GAGd,IAAK,GAFDI,GAAM,mEACNV,EAAM,GACDtB,EAAI,EAAGA,EAAsB,EAAlB4B,EAASlD,OAAYsB,GAAK,EAE1C,IAAK,GADDiC,IAAaL,EAAS5B,GAAK,IAAM,GAAK,EAAIA,EAAI,GAAM,MAAS,IAAS4B,EAAS5B,EAAI,GAAK,IAAM,GAAK,GAAKA,EAAI,GAAK,GAAM,MAAS,EAAO4B,EAAS5B,EAAI,GAAK,IAAM,GAAK,GAAKA,EAAI,GAAK,GAAM,IACnLM,EAAI,EAAGA,EAAI,EAAGA,IACuBgB,GAAlC,EAAJtB,EAAY,EAAJM,EAA0B,GAAlBsB,EAASlD,OAAoBwD,OACrCF,EAAID,OAAQE,GAAW,GAAK,EAAI3B,GAAM,GAG1D,OAAOgB,GAvLX,GAAIQ,SAAU,EACVI,OAAS,GACTvD,MAAQ","file":"sha1.js","sourcesContent":["/*   \r\n *   A   JavaScript   implementation   of   the   Secure   Hash   Algorithm,   SHA-1,   as   defined   \r\n *   in   FIPS   PUB   180-1   \r\n *   Version   2.1-BETA   Copyright   Paul   Johnston   2000   -   2002.   \r\n *   Other   contributors:   Greg   Holt,   Andrew   Kepert,   Ydnar,   Lostinet   \r\n *   Distributed   under   the   BSD   License   \r\n *   See   http://pajhome.org.uk/crypt/md5   for   details.   \r\n */\r\n/*   \r\n *   Configurable   variables.   You   may   need   to   tweak   these   to   be   compatible   with   \r\n *   the   server-side,   but   the   defaults   work   in   most   cases.   \r\n */\r\nvar hexcase = 0; /*   hex   output   format.   0   -   lowercase;   1   -   uppercase                 */\r\nvar b64pad = \"\"; /*   base-64   pad   character.   \"=\"   for   strict   RFC   compliance       */\r\nvar chrsz = 8; /*   bits   per   input   character.   8   -   ASCII;   16   -   Unicode             */\r\n\r\n/*   \r\n *   These   are   the   functions   you'll   usually   want   to   call   \r\n *   They   take   string   arguments   and   return   either   hex   or   base-64   encoded   strings   \r\n */\r\nfunction hex_sha1(s) {\r\n    return binb2hex(core_sha1(str2binb(s), s.length * chrsz));\r\n}\r\n\r\nfunction b64_sha1(s) {\r\n    return binb2b64(core_sha1(str2binb(s), s.length * chrsz));\r\n}\r\n\r\nfunction str_sha1(s) {\r\n    return binb2str(core_sha1(str2binb(s), s.length * chrsz));\r\n}\r\n\r\nfunction hex_hmac_sha1(key, data) {\r\n    return binb2hex(core_hmac_sha1(key, data));\r\n}\r\n\r\nfunction b64_hmac_sha1(key, data) {\r\n    return binb2b64(core_hmac_sha1(key, data));\r\n}\r\n\r\nfunction str_hmac_sha1(key, data) {\r\n    return binb2str(core_hmac_sha1(key, data));\r\n}\r\n\r\n/*   \r\n *   Perform   a   simple   self-test   to   see   if   the   VM   is   working   \r\n */\r\nfunction sha1_vm_test() {\r\n    return hex_sha1(\"abc\") == \"a9993e364706816aba3e25717850c26c9cd0d89d\";\r\n}\r\n\r\n/*   \r\n *   Calculate   the   SHA-1   of   an   array   of   big-endian   words,   and   a   bit   length   \r\n */\r\nfunction core_sha1(x, len) {\r\n    /*   append   padding   */\r\n    x[len >> 5] |= 0x80 << (24 - len % 32);\r\n    x[((len + 64 >> 9) << 4) + 15] = len;\r\n\r\n    var w = Array(80);\r\n    var a = 1732584193;\r\n    var b = -271733879;\r\n    var c = -1732584194;\r\n    var d = 271733878;\r\n    var e = -1009589776;\r\n\r\n    for (var i = 0; i < x.length; i += 16) {\r\n        var olda = a;\r\n        var oldb = b;\r\n        var oldc = c;\r\n        var oldd = d;\r\n        var olde = e;\r\n\r\n        for (var j = 0; j < 80; j++) {\r\n            if (j < 16) w[j] = x[i + j];\r\n            else w[j] = rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\r\n            var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));\r\n            e = d;\r\n            d = c;\r\n            c = rol(b, 30);\r\n            b = a;\r\n            a = t;\r\n        }\r\n\r\n        a = safe_add(a, olda);\r\n        b = safe_add(b, oldb);\r\n        c = safe_add(c, oldc);\r\n        d = safe_add(d, oldd);\r\n        e = safe_add(e, olde);\r\n    }\r\n    return Array(a, b, c, d, e);\r\n\r\n}\r\n\r\n/*   \r\n *   Perform   the   appropriate   triplet   combination   function   for   the   current   \r\n *   iteration   \r\n */\r\nfunction sha1_ft(t, b, c, d) {\r\n    if (t < 20) return (b & c) | ((~b) & d);\r\n    if (t < 40) return b ^ c ^ d;\r\n    if (t < 60) return (b & c) | (b & d) | (c & d);\r\n    return b ^ c ^ d;\r\n}\r\n\r\n/*   \r\n *   Determine   the   appropriate   additive   constant   for   the   current   iteration   \r\n */\r\nfunction sha1_kt(t) {\r\n    return (t < 20) ? 1518500249 : (t < 40) ? 1859775393 : (t < 60) ? -1894007588 : -899497514;\r\n}\r\n\r\n/*   \r\n *   Calculate   the   HMAC-SHA1   of   a   key   and   some   data   \r\n */\r\nfunction core_hmac_sha1(key, data) {\r\n    var bkey = str2binb(key);\r\n    if (bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);\r\n\r\n    var ipad = Array(16),\r\n        opad = Array(16);\r\n    for (var i = 0; i < 16; i++) {\r\n        ipad[i] = bkey[i] ^ 0x36363636;\r\n        opad[i] = bkey[i] ^ 0x5C5C5C5C;\r\n    }\r\n\r\n    var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);\r\n    return core_sha1(opad.concat(hash), 512 + 160);\r\n}\r\n\r\n/*   \r\n *   Add   integers,   wrapping   at   2^32.   This   uses   16-bit   operations   internally   \r\n *   to   work   around   bugs   in   some   JS   interpreters.   \r\n */\r\nfunction safe_add(x, y) {\r\n    var lsw = (x & 0xFFFF) + (y & 0xFFFF);\r\n    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\r\n    return (msw << 16) | (lsw & 0xFFFF);\r\n}\r\n\r\n/*   \r\n *   Bitwise   rotate   a   32-bit   number   to   the   left.   \r\n */\r\nfunction rol(num, cnt) {\r\n    return (num << cnt) | (num >>> (32 - cnt));\r\n}\r\n\r\n/*   \r\n *   Convert   an   8-bit   or   16-bit   string   to   an   array   of   big-endian   words   \r\n *   In   8-bit   function,   characters   >255   have   their   hi-byte   silently   ignored.   \r\n */\r\nfunction str2binb(str) {\r\n    var bin = Array();\r\n    var mask = (1 << chrsz) - 1;\r\n    for (var i = 0; i < str.length * chrsz; i += chrsz)\r\n    bin[i >> 5] |= (str.charCodeAt(i / chrsz) & mask) << (24 - i % 32);\r\n    return bin;\r\n}\r\n\r\n/*   \r\n *   Convert   an   array   of   big-endian   words   to   a   string   \r\n */\r\nfunction binb2str(bin) {\r\n    var str = \"\";\r\n    var mask = (1 << chrsz) - 1;\r\n    for (var i = 0; i < bin.length * 32; i += chrsz)\r\n    str += String.fromCharCode((bin[i >> 5] >>> (24 - i % 32)) & mask);\r\n    return str;\r\n}\r\n\r\n/*   \r\n *   Convert   an   array   of   big-endian   words   to   a   hex   string.   \r\n */\r\nfunction binb2hex(binarray) {\r\n    var hex_tab = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\";\r\n    var str = \"\";\r\n    for (var i = 0; i < binarray.length * 4; i++) {\r\n        str += hex_tab.charAt((binarray[i >> 2] >> ((3 - i % 4) * 8 + 4)) & 0xF) + hex_tab.charAt((binarray[i >> 2] >> ((3 - i % 4) * 8)) & 0xF);\r\n    }\r\n    return str;\r\n}\r\n\r\n/*   \r\n *   Convert   an   array   of   big-endian   words   to   a   base-64   string   \r\n */\r\nfunction binb2b64(binarray) {\r\n    var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n    var str = \"\";\r\n    for (var i = 0; i < binarray.length * 4; i += 3) {\r\n        var triplet = (((binarray[i >> 2] >> 8 * (3 - i % 4)) & 0xFF) << 16) | (((binarray[i + 1 >> 2] >> 8 * (3 - (i + 1) % 4)) & 0xFF) << 8) | ((binarray[i + 2 >> 2] >> 8 * (3 - (i + 2) % 4)) & 0xFF);\r\n        for (var j = 0; j < 4; j++) {\r\n            if (i * 8 + j * 6 > binarray.length * 32) str += b64pad;\r\n            else str += tab.charAt((triplet >> 6 * (3 - j)) & 0x3F);\r\n        }\r\n    }\r\n    return str;\r\n}"]}